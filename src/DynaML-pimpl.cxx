// Not copyrighted - public domain.
//
// This sample parser implementation was generated by CodeSynthesis XSD,
// an XML Schema to C++ data binding compiler. You may use it in your
// programs without any restrictions.
//

#include "DynaML-pimpl.hxx"

#include <iostream>
#include "smallmath.h"
#include "edge.h"

// UsesMeasNetwork
//
void UsesMeasNetwork::setMeasNetwork(MeasNetwork * mn)
{
  _mn = mn;
}

// Clusterpoint_pimpl
//

void Clusterpoint_pimpl::
pre ()
{
	if (!_mn) throw std::runtime_error("MeasNetwork not set for YCluster Parser.");
	_y.reset(new ClusterPoint_Struct); // FIXME make nicer way to get ID.
}

void Clusterpoint_pimpl::
X (const ::std::string& X)
{
  //std::cout << "X: " << X << std::endl;
  _y->_X = ::std::stod(X);
}

void Clusterpoint_pimpl::
Y (const ::std::string& Y)
{
  //std::cout << "Y: " << Y << std::endl;
  _y->_Y = ::std::stod(Y);
}

void Clusterpoint_pimpl::
Z (const ::std::string& Z)
{
  //std::cout << "Z: " << Z << std::endl;
  _y->_Z = ::std::stod(Z);
}

void Clusterpoint_pimpl::
SigmaXX (const ::std::string& SigmaXX)
{
  //std::cout << "SigmaXX: " << SigmaXX << std::endl;
  _y->_Sigma.XX = ::std::stod(SigmaXX);
}

void Clusterpoint_pimpl::
SigmaXY (const ::std::string& SigmaXY)
{
  //std::cout << "SigmaXY: " << SigmaXY << std::endl;
  _y->_Sigma.XY = ::std::stod(SigmaXY);
}

void Clusterpoint_pimpl::
SigmaXZ (const ::std::string& SigmaXZ)
{
  //std::cout << "SigmaXZ: " << SigmaXZ << std::endl;
  _y->_Sigma.XZ = ::std::stod(SigmaXZ);
}

void Clusterpoint_pimpl::
SigmaYY (const ::std::string& SigmaYY)
{
  //std::cout << "SigmaYY: " << SigmaYY << std::endl;
  _y->_Sigma.YY = ::std::stod(SigmaYY);
}

void Clusterpoint_pimpl::
SigmaYZ (const ::std::string& SigmaYZ)
{
  //std::cout << "SigmaYZ: " << SigmaYZ << std::endl;
  _y->_Sigma.YZ = ::std::stod(SigmaYZ);
}

void Clusterpoint_pimpl::
SigmaZZ (const ::std::string& SigmaZZ)
{
  //std::cout << "SigmaZZ: " << SigmaZZ << std::endl;
  _y->_Sigma.ZZ = ::std::stod(SigmaZZ);
}

void Clusterpoint_pimpl::
PointCovariance (const ::arma::mat33& PointCovariance)
{
  // TODO
  //
  _y->_point_covar.push_back(PointCovariance);
}

::ClusterPoint_Struct& Clusterpoint_pimpl::
post_Clusterpoint ()
{
  // TODO
  //
  // return ... ;
  return *_y.get();
}

// Directions_pimpl
//

void Directions_pimpl::
pre ()
{
	if (!_mn) throw std::runtime_error("MeasNetwork not set for Directions Parser.");
	_d.reset(new Directions_Struct); // FIXME make nicer way to get ID.
}

void Directions_pimpl::
Ignore (const ::std::string& Ignore)
{
  //std::cout << "Ignore: " << Ignore << std::endl;
  _d->_Ignore = Ignore.length() > 0;
}

void Directions_pimpl::
Target (const ::std::string& Target)
{
  //std::cout << "Target: " << Target << std::endl;
  _d->_Target = Target;
}

void Directions_pimpl::
Value (const ::std::string& Value)
{
  //std::cout << "Value: " << Value << std::endl;
  _d->_Value = ::std::stod(Value);
}

void Directions_pimpl::
StdDev (const ::std::string& StdDev)
{
  //std::cout << "StdDev: " << StdDev << std::endl;
  _d->_StdDev = ::std::stod(StdDev);
}

::Directions_Struct& Directions_pimpl::
post_Directions ()
{
  // TODO
  //
  // return ... ;
  return *_d.get();
}

// DnaMeasurement_pimpl
//

void DnaMeasurement_pimpl::
pre ()
{
	_m.reset(new DnaMeasurement_Struct);
	_clusterpoints.clear();
	_gpsbaselines.clear();
	_directions.clear();
	_params.clear();
}

void DnaMeasurement_pimpl::
Type (const ::std::string& Type)
{
  //std::cout << "Type: " << Type << std::endl;
  _m->_Type = Type;
}

void DnaMeasurement_pimpl::
Ignore (const ::std::string& Ignore)
{
  //std::cout << "Ignore: " << Ignore << std::endl;
  _m->_Ignore = Ignore;
}

void DnaMeasurement_pimpl::
First (const ::std::string& First)
{
  //std::cout << "First: " << First << std::endl;
  addStation(First);
}

void DnaMeasurement_pimpl::
Second (const ::std::string& Second)
{
  //std::cout << "Second: " << Second << std::endl;
  addStation(Second);
}

void DnaMeasurement_pimpl::
Third (const ::std::string& Third)
{
  //std::cout << "Third: " << Third << std::endl;
  addStation(Third);
}

void DnaMeasurement_pimpl::
Value (const ::std::string& Value)
{
  //std::cout << "Value: " << Value << std::endl;
  _m->_Value = Value;
}

void DnaMeasurement_pimpl::
StdDev (const ::std::string& StdDev)
{
  //std::cout << "StdDev: " << StdDev << std::endl;
  _m->_StdDev = StdDev;
}

void DnaMeasurement_pimpl::
InstHeight (const ::std::string& InstHeight)
{
  //std::cout << "InstHeight: " << InstHeight << std::endl;
  _m->_InstHeight = InstHeight;
}

void DnaMeasurement_pimpl::
TargHeight (const ::std::string& TargHeight)
{
  //std::cout << "TargHeight: " << TargHeight << std::endl;
  _m->_TargHeight = TargHeight;
}

void DnaMeasurement_pimpl::
Total (const ::std::string& Total)
{
  //std::cout << "Total: " << Total << std::endl;
  _m->_Total = Total;
}

void DnaMeasurement_pimpl::
Directions (::Directions_Struct& Directions)
{
  // TODO
  //
  _directions.push_back(Directions);
}

void DnaMeasurement_pimpl::
Vscale (const ::std::string& Vscale)
{
  //std::cout << "Vscale: " << Vscale << std::endl;
  _m->_Vscale = Vscale;
}

void DnaMeasurement_pimpl::
GPSBaseline (::GPSBaseline_Struct& GPSBaseline)
{
  // TODO
  //
  _gpsbaselines.push_back(GPSBaseline);
}

void DnaMeasurement_pimpl::
Hscale (const ::std::string& Hscale)
{
  //std::cout << "Hscale: " << Hscale << std::endl;
  _m->_Hscale = Hscale;
}

void DnaMeasurement_pimpl::
Lscale (const ::std::string& Lscale)
{
  //std::cout << "Lscale: " << Lscale << std::endl;
  _m->_Lscale = Lscale;
}

void DnaMeasurement_pimpl::
Pscale (const ::std::string& Pscale)
{
  //std::cout << "Pscale: " << Pscale << std::endl;
  _m->_Pscale = Pscale;
}

void DnaMeasurement_pimpl::
Clusterpoint (::ClusterPoint_Struct& Clusterpoint)
{
  // TODO
  //
  _clusterpoints.push_back(Clusterpoint);
}

void DnaMeasurement_pimpl::
Coords (const ::std::string& Coords)
{
  //std::cout << "Coords: " << Coords << std::endl;
  _m->_Coords = Coords;
}

void DnaMeasurement_pimpl::
Source (const ::std::string& Source)
{
  //std::cout << "Source: " << Source << std::endl;
  _m->_Source = Source;
}

void DnaMeasurement_pimpl::
ReferenceFrame (const ::std::string& ReferenceFrame)
{
  //std::cout << "ReferenceFrame: " << ReferenceFrame << std::endl;
  _m->_ReferenceFrame = ReferenceFrame;
}

void DnaMeasurement_pimpl::
MeasuredDate (const ::std::string& MeasuredDate)
{
  //std::cout << "MeasuredDate: " << MeasuredDate << std::endl;
  _m->_MeasuredDate = MeasuredDate;
}

::DnaMeasurement* DnaMeasurement_pimpl::
post_DnaMeasurement ()
{
  //::DnaMeasurement * _measurement;
  ::DnaMeasurement *_measurement;
  // TODO
  //
  // return ... ;
  switch (_m->_Type[0]) {
    case 'G':
		{
	  ::GPSBaseline * _bl = new ::GPSBaseline(id());
	  if (!_gpsbaselines.size()) throw ::std::domain_error("No GPSBaseline element found.");
	  // just get the first.
	  GPSBaseline_Struct * g = &_gpsbaselines.front();
	  _bl->_components[0] = g->_X;
	  _bl->_components[1] = g->_Y;
	  _bl->_components[2] = g->_Z;
	  double rawvcv[6];
	  rawvcv[0] = g->_Sigma.XX;
	  rawvcv[1] = g->_Sigma.XY;
	  rawvcv[2] = g->_Sigma.XZ;
	  rawvcv[3] = g->_Sigma.YY;
	  rawvcv[4] = g->_Sigma.YZ;
	  rawvcv[5] = g->_Sigma.ZZ;
	  _bl->setRawVCV(rawvcv);
	  // ignore point covars
	  // for GPS baselines only, set edge joins
	  assert(_params.size() == 2);
	  Station * First = _params[0].second;
	  Station * Second = _params[1].second;
	  unsigned long FirstIndex = _params[0].first;
	  unsigned long SecondIndex = _params[1].first;
	  First->stnJoin.push_back(SecondIndex);
      Second->stnJoin.push_back(FirstIndex); //-
      First->edgeJoin.push_back(edge(id(),SecondIndex,Second));
      Second->edgeJoin.push_back(edge(id(),FirstIndex,First));
	  First->measJoin.push_back(id());
	  Second->measJoin.push_back(id());
	  //copy pointer
	  _measurement = _bl;
	  // copy all params
	  for (int ii=0;ii<_params.size();++ii) _measurement->_param.push_back(_params[ii].second);
		}
	  break;
		
	case 'Y':
		{
	  YCluster * _yc = new YCluster(id(), ::std::stod(_m->_Total)); // TODO check against _params.size();
	  if (!_clusterpoints.size()) throw ::std::domain_error("No ClusterPoint element found.");
	  // loop through all clusterpoints
	  int stn_id = 0;
	  for (::std::vector<ClusterPoint_Struct>::iterator c = _clusterpoints.begin(); c != _clusterpoints.end(); ++c) {
		  _yc->setPoint(stn_id,_params[stn_id].second,c->_X,c->_Y,c->_Z);
		  double rawvcv[6];
		  rawvcv[0] = c->_Sigma.XX;
		  rawvcv[1] = c->_Sigma.XY;
		  rawvcv[2] = c->_Sigma.XZ;
		  rawvcv[3] = c->_Sigma.YY;
		  rawvcv[4] = c->_Sigma.YZ;
		  rawvcv[5] = c->_Sigma.ZZ;
		  _yc->setStationRawVCV(stn_id, rawvcv);
		  
		  int to_stn_id = stn_id + 1;
		  for( int covi=0; covi < c->_point_covar.size(); ++covi)
		  {
			_yc->set2StationCovariance(stn_id, to_stn_id, c->_point_covar[covi]);
			to_stn_id++;
		  }
		  stn_id++;
	  }
	  _measurement = _yc;
	  if (_yc->TotalSize != _yc->_param.size()) throw ::std::domain_error("Number of parameter groups does not match specified Total.");
		}
	  break;
	case 'H':
	case 'A':
	case 'B':
	case 'C':
	case 'E':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'V':
	case 'X':
	case 'Z':
	case 'D':
		return NULL; // do nothing at this stage!
	  //_measurement.reset(new Directions(id()));
	  //if (!_directions.size()) throw domain_error("No Directions element found.");
	  //break;
	default:
	  throw ::std::domain_error(
		  ::std::string("Unsupported measurement type ") + _m->_Type
	  );
  }


  // copy all strings into the child meas.
  _measurement->Type = _m->_Type[0];
  _measurement->Ignore = _m->_Ignore.length();

  //_measurement->Value = _m->_Value;
  //_measurement->StdDev = _m->_StdDev;
  //_measurement->InstHeight = _m->_InstHeight;
  //_measurement->TargHeight = _m->_TargHeight;
  //_measurement->Total = _m->_Total;
  _measurement->Vscale = _m->_Vscale.length() ? ::std::stod(_m->_Vscale) : 1;
  _measurement->Hscale = _m->_Hscale.length() ? ::std::stod(_m->_Hscale) : 1;
  _measurement->Lscale = _m->_Lscale.length() ? ::std::stod(_m->_Lscale) : 1;
  _measurement->Pscale = _m->_Pscale.length() ? ::std::stod(_m->_Pscale) : 1;
  //_measurement->Coords = _m->_Coords;
  //_measurement->Source = _m->_Source;
  //_measurement->ReferenceFrame = _m->_ReferenceFrame;
  
  return dynamic_cast<::DnaMeasurement*>(_measurement);
}

// DnaMeasurement_pimpl custom methods
// FIXME assumes this station has not already been added to this measurement
void DnaMeasurement_pimpl::addStation(const ::std::string& stn_str)
{
	assert(_mn);
	Station* P = NULL;
    int Index  = _mn->getPointIndex(stn_str.c_str(),&P);
    _params.push_back(::std::pair<int,Station*>(Index,P));
	//P->stnJoin.push_back(??);
	//P->edgeJoin.push_back(edge(i,??,??));
}

unsigned long DnaMeasurement_pimpl::id()
{
	assert(_mn);
	return _mn->_numMeasurements;
}

// DnaStation_pimpl
//

void DnaStation_pimpl::
pre ()
{
	if (!_mn) throw std::runtime_error("MeasNetwork not set for Station Parser.");
	_stn.reset(new Station_Struct);
}

void DnaStation_pimpl::
Name (const ::std::string& Name)
{
  //std::cout << "Name: " << Name << std::endl;
  _stn->_Name = Name;
}

void DnaStation_pimpl::
Constraints (const ::std::string& Constraints)
{
  //std::cout << "Constraints: " << Constraints << std::endl;
  _stn->_Constraints = Constraints;
  // Do nothing
}

void DnaStation_pimpl::
Type (const ::std::string& Type)
{
  //std::cout << "Type: " << Type << std::endl;
  _stn->_Type = Type;
  // Do nothing.
}

void DnaStation_pimpl::
StationCoord (const ::StationCoord_Struct& StationCoord)
{
  // TODO
  // Fetch all elements and assign to the station.
	_stn->_Coord = StationCoord;
}

void DnaStation_pimpl::
Description (const ::std::string& Description)
{
  //std::cout << "Description: " << Description << std::endl;
  _stn->_Description = Description;
  // Do nothing.
}

::Station& DnaStation_pimpl::
post_DnaStation ()
{
  // TODO
  //
  // return ... ;
  Station * stn = NULL;
  int stationID = _mn->getPointIndex(_stn->_Coord._Name.c_str(),&stn);
	stn->Latitude = _stn->_Coord._XAxis;
	stn->LatitudeStr = _stn->_Coord._XAxisStr;
	stn->Longitude = _stn->_Coord._YAxis;
	stn->LongitudeStr = _stn->_Coord._YAxisStr;
	stn->Height = _stn->_Coord._Height;
	stn->name = _stn->_Coord._Name;
	stn->setConstraints(_stn->_Constraints); // currently assumes ENU
	// TODO should be done inside station class
	double Xc[3] = {0,0,0};
	double Xg[3] = {stn->Latitude,stn->Longitude,stn->Height};
	//convertGeodeticDMStoDecDeg(Xg); // necessary because station LLH is in DDD.MMSS.SSSS
	convertGeodeticToCartesian(Xg,Xc,GRS80_A,GRS80_eccSq);
	::std::vector<double> xyz;
   	for (int iii=0;iii<3;iii++) xyz.push_back(Xc[iii]);
	stn->setAprioriValues(xyz); // seg -1 == apriori coordinates
    // set station constraints

  // return a reference. We won't use it though.
  return *stn;
}

// DnaXmlFormat_pimpl
//

// DnaXmlFormat_pimpl
//

void DnaXmlFormat_pimpl::
pre ()
{
	_loadcounter = 0;
	// init measurements and stations perhaps?
}

void DnaXmlFormat_pimpl::
DnaStation (::Station& DnaStation)
{
  if (_loadcounter == 600) {
	  _loadcounter = 0;
	  std::cout << "\b\b\b\b\b     \b\b\b\b\b";
  } else if (_loadcounter % 100 == 0) {
	  std::cout << ".";
  }
  _loadcounter++;
  // TODO
  // Add the station to the list of stations
  // Should already be in the list of stations, so do nothing.
}

void DnaXmlFormat_pimpl::
DnaMeasurement (::DnaMeasurement* DnaMeasurement)
{
  if (_loadcounter == 600) {
	  _loadcounter = 0;
	  std::cout << "\b\b\b\b\b     \b\b\b\b\b";
  } else if (_loadcounter % 100 == 0) {
	  std::cout << ".";
  }
  _loadcounter++;
  // TODO
  // Add the measurement to the list of measurements
  //FIXME make it always add the measurement, but only ignore in Jacobian formulation.
  if (DnaMeasurement && (_mn->_include_ignores || !DnaMeasurement->Ignore)) {
	  _mn->_measurements.push_back(DnaMeasurement);
	  _mn->_numMeasurements++;
  }
}

void DnaXmlFormat_pimpl::
type ()
{
}

void DnaXmlFormat_pimpl::
post_DnaXmlFormat ()
{
	while ((_loadcounter -= 100) > 0) std::cout << "\b \b";
}

// GPSBaseline_pimpl
//

void GPSBaseline_pimpl::
pre ()
{
	if (!_mn) throw std::runtime_error("MeasNetwork not set for GPSBaseline Parser.");
	_bl.reset(new GPSBaseline_Struct);
}

void GPSBaseline_pimpl::
X (const ::std::string& X)
{
  //std::cout << "X: " << X << std::endl;
  _bl->_X = std::stod(X);
}

void GPSBaseline_pimpl::
Y (const ::std::string& Y)
{
  //std::cout << "Y: " << Y << std::endl;
  _bl->_Y = std::stod(Y);
}

void GPSBaseline_pimpl::
Z (const ::std::string& Z)
{
  //std::cout << "Z: " << Z << std::endl;
  _bl->_Z = std::stod(Z);
}

void GPSBaseline_pimpl::
SigmaXX (const ::std::string& SigmaXX)
{
  //std::cout << "SigmaXX: " << SigmaXX << std::endl;
  _bl->_Sigma.XX = std::stod(SigmaXX);
}

void GPSBaseline_pimpl::
SigmaXY (const ::std::string& SigmaXY)
{
  //std::cout << "SigmaXY: " << SigmaXY << std::endl;
  _bl->_Sigma.XY = std::stod(SigmaXY);
}

void GPSBaseline_pimpl::
SigmaXZ (const ::std::string& SigmaXZ)
{
  //std::cout << "SigmaXZ: " << SigmaXZ << std::endl;
  _bl->_Sigma.XZ = std::stod(SigmaXZ);
}

void GPSBaseline_pimpl::
SigmaYY (const ::std::string& SigmaYY)
{
  //std::cout << "SigmaYY: " << SigmaYY << std::endl;
  _bl->_Sigma.YY = std::stod(SigmaYY);
}

void GPSBaseline_pimpl::
SigmaYZ (const ::std::string& SigmaYZ)
{
  //std::cout << "SigmaYZ: " << SigmaYZ << std::endl;
  _bl->_Sigma.YZ = std::stod(SigmaYZ);
}

void GPSBaseline_pimpl::
SigmaZZ (const ::std::string& SigmaZZ)
{
  //std::cout << "SigmaZZ: " << SigmaZZ << std::endl;
  _bl->_Sigma.ZZ = std::stod(SigmaZZ);
}

void GPSBaseline_pimpl::
GPSCovariance (const ::arma::mat33& GPSCovariance)
{
  // TODO
  //
}

::GPSBaseline_Struct& GPSBaseline_pimpl::
post_GPSBaseline ()
{
  // TODO
  //
  // return ... ;

  return *(_bl.get());
}

// GPSCovariance_pimpl
//

void GPSCovariance_pimpl::
pre ()
{
  _pointcovar.zeros();
}

void GPSCovariance_pimpl::
m11 (const ::std::string& m11)
{
  //std::cout << "m11: " << m11 << std::endl;
  _pointcovar(0,0) = ::std::stod(m11);
}

void GPSCovariance_pimpl::
m12 (const ::std::string& m12)
{
  //std::cout << "m12: " << m12 << std::endl;
  _pointcovar(0,1) = ::std::stod(m12);
}

void GPSCovariance_pimpl::
m13 (const ::std::string& m13)
{
  //std::cout << "m13: " << m13 << std::endl;
  _pointcovar(0,2) = ::std::stod(m13);
}

void GPSCovariance_pimpl::
m21 (const ::std::string& m21)
{
  //std::cout << "m21: " << m21 << std::endl;
  _pointcovar(1,0) = ::std::stod(m21);
}

void GPSCovariance_pimpl::
m22 (const ::std::string& m22)
{
  //std::cout << "m22: " << m22 << std::endl;
  _pointcovar(1,1) = ::std::stod(m22);
}

void GPSCovariance_pimpl::
m23 (const ::std::string& m23)
{
  //std::cout << "m23: " << m23 << std::endl;
  _pointcovar(1,2) = ::std::stod(m23);
}

void GPSCovariance_pimpl::
m31 (const ::std::string& m31)
{
  //std::cout << "m31: " << m31 << std::endl;
  _pointcovar(2,0) = ::std::stod(m31);
}

void GPSCovariance_pimpl::
m32 (const ::std::string& m32)
{
  //std::cout << "m32: " << m32 << std::endl;
  _pointcovar(2,1) = ::std::stod(m32);
}

void GPSCovariance_pimpl::
m33 (const ::std::string& m33)
{
  //std::cout << "m33: " << m33 << std::endl;
  _pointcovar(2,2) = ::std::stod(m33);
}

::arma::mat33 GPSCovariance_pimpl::
post_GPSCovariance ()
{
  // TODO
  //
  // return ... ;
  return _pointcovar;
}

// PointCovariance_pimpl
//

void PointCovariance_pimpl::
pre ()
{
  _pointcovar.zeros();
}

void PointCovariance_pimpl::
m11 (const ::std::string& m11)
{
  //std::cout << "m11: " << m11 << std::endl;
  _pointcovar(0,0) = ::std::stod(m11);
}

void PointCovariance_pimpl::
m12 (const ::std::string& m12)
{
  //std::cout << "m12: " << m12 << std::endl;
  _pointcovar(0,1) = ::std::stod(m12);
}

void PointCovariance_pimpl::
m13 (const ::std::string& m13)
{
  //std::cout << "m13: " << m13 << std::endl;
  _pointcovar(0,2) = ::std::stod(m13);
}

void PointCovariance_pimpl::
m21 (const ::std::string& m21)
{
  //std::cout << "m21: " << m21 << std::endl;
  _pointcovar(1,0) = ::std::stod(m21);
}

void PointCovariance_pimpl::
m22 (const ::std::string& m22)
{
  //std::cout << "m22: " << m22 << std::endl;
  _pointcovar(1,1) = ::std::stod(m22);
}

void PointCovariance_pimpl::
m23 (const ::std::string& m23)
{
  //std::cout << "m23: " << m23 << std::endl;
  _pointcovar(1,2) = ::std::stod(m23);
}

void PointCovariance_pimpl::
m31 (const ::std::string& m31)
{
  //std::cout << "m31: " << m31 << std::endl;
  _pointcovar(2,0) = ::std::stod(m31);
}

void PointCovariance_pimpl::
m32 (const ::std::string& m32)
{
  //std::cout << "m32: " << m32 << std::endl;
  _pointcovar(2,1) = ::std::stod(m32);
}

void PointCovariance_pimpl::
m33 (const ::std::string& m33)
{
  //std::cout << "m33: " << m33 << std::endl;
  _pointcovar(2,2) = ::std::stod(m33);
}

::arma::mat33 PointCovariance_pimpl::
post_PointCovariance ()
{
  // TODO
  //
  // return ... ;
  return _pointcovar;
}

// StationCoord_pimpl
//


void StationCoord_pimpl::
pre ()
{
	_stncoord.reset(new StationCoord_Struct);
}

void StationCoord_pimpl::
Name (const ::std::string& Name)
{
  //std::cout << "Name: " << Name << std::endl;
  this->_stncoord->_Name=Name;
}

void StationCoord_pimpl::
XAxis (const ::std::string& XAxis)
{
  //std::cout << "XAxis: " << XAxis << std::endl;
  this->_stncoord->_XAxisStr=XAxis;
  this->_stncoord->_XAxis=dmsStringToDouble(XAxis);
}

void StationCoord_pimpl::
YAxis (const ::std::string& YAxis)
{
  //std::cout << "YAxis: " << YAxis << std::endl;
  this->_stncoord->_YAxisStr=YAxis;
  this->_stncoord->_YAxis=dmsStringToDouble(YAxis);
}

void StationCoord_pimpl::
Height (const ::std::string& Height)
{
  //std::cout << "Height: " << Height << std::endl;
  this->_stncoord->_Height=::std::stod(Height);
}

void StationCoord_pimpl::
HemisphereZone (const ::std::string& HemisphereZone)
{
  //std::cout << "HemisphereZone: " << HemisphereZone << std::endl;
  this->_stncoord->_HemisphereZone=HemisphereZone;
}

::StationCoord_Struct StationCoord_pimpl::
post_StationCoord ()
{
  // TODO
  //
  // return ... ;
  return *_stncoord.get();
}

// type_pimpl
//

void type_pimpl::
pre ()
{
}

void type_pimpl::
post_type ()
{
  const ::std::string& v (post_string ());

  //std::cout << "type: " << v << std::endl;
}

